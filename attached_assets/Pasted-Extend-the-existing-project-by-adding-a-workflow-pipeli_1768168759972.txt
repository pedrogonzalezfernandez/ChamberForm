Extend the existing project by adding a “workflow pipeline” system and 10 new music21 workflows.

Main UX change (pipeline + selection always available)
1) Add a persistent “Selection” panel that always applies before any workflow runs:
   - Select part: dropdown (All parts / each part name: Violin I, Viola, etc.)
   - Select region: start measure, end measure (existing) + optional “only this part”
   - (Optional v0.1) If a measure contains multiple voices/streams, just keep them all; don’t overcomplicate.
2) Add a “Pipeline” panel where the user can chain steps:
   - The user can run Workflow A, then Workflow B on the result (like a Python script where you do one thing, inspect, then do another).
   - Internally, keep a “workspace object” per scoreId containing:
     - the original music21 Score
     - the current selected sub-score / sub-stream (after selection + any transform workflows)
     - cached results from each workflow step (JSON)
   - Provide UI controls: “Run step”, “Add step”, “Remove step”, “Reset to original”, “Re-run all”.
3) Every workflow must accept the current selection context:
   input = {scoreId, selection:{partId|ALL, startMeasure, endMeasure}, params:{}}
   output = JSON with:
   - annotations for display (timeline/measure list; optional score overlay if feasible)
   - (optional) playback events for Tone.js
   - (optional) transformedScore (if the workflow creates a new derived score; store it in workspace)

Backend architecture change (important)
- Expand the existing music21 workflow registry to support:
  - “analysis workflows” (return JSON)
  - “transform workflows” (return JSON + new derived music21 stream to become the current workspace stream)
- Add endpoints:
  - GET /api/workflows  -> list all workflows with id, name, type, params schema, short description
  - POST /api/pipeline/runStep -> runs a workflow on current selection/workspace and updates workspace
  - POST /api/pipeline/reset -> resets workspace to original score
  - (Keep existing upload endpoint; update it to initialize workspace.)

Rendering requirement
- Keep Verovio rendering in the browser.
- If the current workspace stream is transformed (e.g., reduction), allow re-render:
  - Provide endpoint to export the current workspace stream to MEI (or format Verovio can render) and return it so the UI can show “Derived view”.
  - If converting transformed stream to MEI is hard, show analysis in panels for v0.1 and keep the score view as the original; but still keep the transformed stream in the backend workspace for further steps.

Now implement these 10 workflows (prioritize robustness; chamber-music oriented)
Each workflow must work on the selected part+measure range (or all parts in that range). Keep them simple and deterministic.

1) WORKFLOW: score_summary (analysis)
   - Output: title/composer, part names, measure count, time signatures, tempo marks, key signatures in the selected range.

2) WORKFLOW: global_key_estimate (analysis)
   - Output: estimated key for the selected region + confidence/notes if available.

3) WORKFLOW: chordify_and_chords (analysis)
   - Chordify the selected region (all parts) and compute chord labels.
   - Output: list per measure (or per beat if feasible) with chord label + pitch list (name + midi).

4) WORKFLOW: roman_numeral_analysis (analysis)
   - Use music21 romanNumeral tools in the context of the estimated key.
   - Output: roman numerals per measure (or per beat), plus local key if you compute modulations (keep optional).

5) WORKFLOW: cadence_spotter (analysis)
   - Heuristic detection of cadence-like points (e.g., V–I or V–i, ii–V–I, V7–I).
   - Output: measure numbers + cadence type + short explanation.

6) WORKFLOW: interval_map_between_parts (analysis)
   - Parameters: partA, partB (dropdowns), optionally “harmonic intervals only at onsets”.
   - Output: for each measure/beat/onset: harmonic interval class (e.g., m3, P5, M6), plus counts summary.

7) WORKFLOW: parallel_5ths_8ves_detector (analysis)
   - Parameters: partA, partB
   - Output: list of detected parallels with measure numbers and the involved pitches.

8) WORKFLOW: rhythm_skeleton (analysis + optional playback events)
   - For each part, extract onset times (quantized to beat subdivisions) and show a per-measure onset list.
   - Optional: generate a click/clave pattern events for Tone.js (simple per-beat ticks, accents on strong beats).

9) WORKFLOW: motif_finder_interval_contour (analysis)
   - Parameters: choose part, choose motif length (default 4–6 notes).
   - Find repeated interval-contour patterns (transposition-invariant) in the selection.
   - Output: motif id + occurrences (start measure/offset), with a short interval pattern string.

10) WORKFLOW: reduction_outer_voices (transform + playback events)
   - Create a derived stream containing only:
     - highest active voice (soprano-ish) + lowest active voice (bass-ish) in the selected region
     - (if piano present, treat LH as bass candidate, RH as soprano candidate)
   - Store this derived stream as the current workspace stream (so subsequent workflows can run on it).
   - Output:
     - summary of which parts were chosen as “outer”
     - playback events for Tone.js using sine tones (polyphonic) so users can tune.
   - UI: “Switch view: Original / Derived (Outer Voices Reduction)” if rendering derived is available.

Frontend tasks
- Add Selection panel (part + measure range).
- Add Pipeline panel:
  - Step list with workflow dropdown + params UI (auto-generated from workflow param schema returned by backend).
  - Buttons: Run step, Add step, Remove step, Run all, Reset.
- Add Results area that shows the latest step output + allows inspecting previous steps.
- Keep existing “Play reduction” controls but route them through the workflow system (so reduction events come from workflow 10).

Implementation notes
- Keep things simple: measure-based resolution is fine for v0.1.
- Focus on correct JSON outputs and stable selection behavior.
- Add basic error handling and clear messages when a workflow can’t run on the selection.

Deliverable
After changes, a user can:
- upload MusicXML
- select (Viola, measures 12–20)
- run global key estimate
- then run motif finder on that same selection
- reset, select all parts, run chordify, run roman numerals, then generate outer-voices reduction and play it in a loop.
